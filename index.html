<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris — Vanilla JS</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111827; --muted:#6b7280; --text:#e5e7eb; --accent:#22d3ee; --good:#34d399; --warn:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,\"Noto Sans\",\"Helvetica Neue\",Arial,\"Apple Color Emoji\",\"Segoe UI Emoji\";background:linear-gradient(120deg,#0b0f14,#0a1420 40%,#081321 100%);color:var(--text);display:flex;min-height:100vh;align-items:center;justify-content:center}
    .wrap{display:grid;grid-template-columns:auto 220px;gap:18px;align-items:start;padding:24px}
    .card{background:rgba(17,24,39,.8);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.05);border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .panel{padding:16px}
    h1{margin:0 0 12px;font-size:20px;letter-spacing:.5px;display:flex;align-items:center;gap:10px}
    .pill{display:inline-flex;align-items:center;gap:6px;background:#0f172a;border:1px solid rgba(255,255,255,.06);padding:6px 10px;border-radius:999px;font-size:12px;color:var(--muted)}
    .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px}
    .stat{padding:10px;border-radius:12px;background:#0b1220;border:1px solid rgba(255,255,255,.06);text-align:center}
    .stat .k{font-size:11px;color:var(--muted)}
    .stat .v{font-size:18px;font-weight:700}
    .grid{position:relative}
    canvas{display:block;background:#0b1220;border-radius:14px;border:1px solid rgba(255,255,255,.06)}
    .controls{margin-top:12px;font-size:12px;color:var(--muted);line-height:1.6}
    kbd{background:#0f172a;border:1px solid rgba(255,255,255,.08);padding:2px 6px;border-radius:6px;font-size:11px}
    .btns{display:flex;gap:8px;margin-top:12px}
    button{all:unset;cursor:pointer;padding:10px 12px;border-radius:12px;background:#0f172a;border:1px solid rgba(255,255,255,.08)}
    button:hover{border-color:rgba(255,255,255,.2)}
    .badge{position:absolute;top:10px;left:10px;background:rgba(34,211,238,.15);border:1px solid rgba(34,211,238,.4);color:#a5f3fc;padding:4px 8px;border-radius:999px;font-size:11px}
    .toast{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .toast span{background:rgba(8,13,25,.7);border:1px solid rgba(255,255,255,.08);padding:8px 12px;border-radius:10px;font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="grid">
      <div class="badge">TETRIS</div>
      <canvas id="board" width="300" height="600" class="card"></canvas>
      <div class="toast" id="toast" aria-live="polite"></div>
    </div>

    <div class="card panel">
      <h1>Neo Tetris <span class="pill">Vanilla JS</span></h1>
      <div class="stats">
        <div class="stat"><div class="k">Score</div><div id="score" class="v">0</div></div>
        <div class="stat"><div class="k">Level</div><div id="level" class="v">1</div></div>
        <div class="stat"><div class="k">Lines</div><div id="lines" class="v">0</div></div>
        <div class="stat"><div class="k">Speed</div><div id="speed" class="v">1x</div></div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
        <div>
          <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Next</div>
          <canvas id="next" width="120" height="120" style="background:#0b1220;border-radius:12px;border:1px solid rgba(255,255,255,.06)"></canvas>
        </div>
        <div>
          <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Hold</div>
          <canvas id="hold" width="120" height="120" style="background:#0b1220;border-radius:12px;border:1px solid rgba(255,255,255,.06)"></canvas>
        </div>
      </div>

      <div class="btns">
        <button id="btn-restart">Restart (R)</button>
        <button id="btn-pause">Pause (P)</button>
      </div>

      <div class="controls">
        <div><kbd>←</kbd> / <kbd>→</kbd> move &nbsp; <kbd>↓</kbd> soft drop</div>
        <div><kbd>↑</kbd> rotate &nbsp; <kbd>Space</kbd> hard drop</div>
        <div><kbd>Shift</kbd> hold piece &nbsp; <kbd>P</kbd> pause</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // === Constants ===
  const COLS = 10, ROWS = 20, BLOCK = 30; // board 300x600
  const DROP_START = 900; // ms
  const SPEED_TABLE = [900, 800, 700, 600, 520, 450, 380, 320, 270, 230, 200, 170, 150, 130, 115, 100, 88, 78, 70, 62];
  const SCORES = {1:100, 2:300, 3:500, 4:800};
  const COLORS = {
    I: '#67e8f9', J: '#60a5fa', L: '#f59e0b', O: '#fde68a', S: '#34d399', T: '#c084fc', Z: '#f87171', GHOST: 'rgba(255,255,255,.12)'
  };
  const SHAPES = {
    I: [
      [[0,1],[1,1],[2,1],[3,1]],
      [[2,0],[2,1],[2,2],[2,3]],
      [[0,2],[1,2],[2,2],[3,2]],
      [[1,0],[1,1],[1,2],[1,3]],
    ],
    J: [
      [[0,0],[0,1],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[1,2]],
      [[0,1],[1,1],[2,1],[2,2]],
      [[1,0],[1,1],[0,2],[1,2]],
    ],
    L: [
      [[2,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[1,2],[2,2]],
      [[0,1],[1,1],[2,1],[0,2]],
      [[0,0],[1,0],[1,1],[1,2]],
    ],
    O: [
      [[1,0],[2,0],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[2,1]],
      [[1,0],[2,0],[1,1],[2,1]],
    ],
    S: [
      [[1,0],[2,0],[0,1],[1,1]],
      [[1,0],[1,1],[2,1],[2,2]],
      [[1,1],[2,1],[0,2],[1,2]],
      [[0,0],[0,1],[1,1],[1,2]],
    ],
    T: [
      [[1,0],[0,1],[1,1],[2,1]],
      [[1,0],[1,1],[2,1],[1,2]],
      [[0,1],[1,1],[2,1],[1,2]],
      [[1,0],[0,1],[1,1],[1,2]],
    ],
    Z: [
      [[0,0],[1,0],[1,1],[2,1]],
      [[2,0],[1,1],[2,1],[1,2]],
      [[0,1],[1,1],[1,2],[2,2]],
      [[1,0],[0,1],[1,1],[0,2]],
    ],
  };

  // === Canvas & UI ===
  const boardCanvas = document.getElementById('board');
  const bctx = boardCanvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('hold');
  const hctx = holdCanvas.getContext('2d');
  const elScore = document.getElementById('score');
  const elLevel = document.getElementById('level');
  const elLines = document.getElementById('lines');
  const elSpeed = document.getElementById('speed');
  const toast = document.getElementById('toast');

  function showToast(msg, ms=1000){
    toast.innerHTML = `<span>${msg}</span>`;
    setTimeout(()=> toast.innerHTML='', ms);
  }

  function drawCell(ctx, x, y, color){
    const s = 24; // size in mini canvases
    ctx.fillStyle = color; ctx.fillRect(x*s+1,y*s+1,s-2,s-2);
  }

  function drawBlock(ctx, x, y, color){
    const px = x*BLOCK, py = y*BLOCK;
    bctx.fillStyle = color; bctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2);
    // subtle gloss
    bctx.fillStyle = 'rgba(255,255,255,.06)'; bctx.fillRect(px+2,py+2,BLOCK-4,Math.max(3,BLOCK*0.12));
    // border
    bctx.strokeStyle = 'rgba(0,0,0,.25)'; bctx.strokeRect(px+.5,py+.5,BLOCK-1,BLOCK-1);
  }

  // === Helpers ===
  const emptyBoard = () => Array.from({length:ROWS},()=> Array(COLS).fill(null));

  function collides(board, piece, ox, oy, rot){
    const shape = SHAPES[piece.type][rot];
    for(const [dx,dy] of shape){
      const x = ox + dx, y = oy + dy;
      if(x<0||x>=COLS||y>=ROWS) return true;
      if(y>=0 && board[y][x]) return true;
    }
    return false;
  }

  function merge(board, piece){
    const shape = SHAPES[piece.type][piece.rot];
    for(const [dx,dy] of shape){
      const x = piece.x + dx, y = piece.y + dy;
      if(y>=0) board[y][x] = piece.type;
    }
  }

  function clearLines(board){
    let cleared = 0;
    for(let y=ROWS-1; y>=0; y--){
      if(board[y].every(Boolean)){
        board.splice(y,1);
        board.unshift(Array(COLS).fill(null));
        cleared++;
        y++;
      }
    }
    return cleared;
  }

  function bag7(){
    const types = ['I','J','L','O','S','T','Z'];
    for(let i=types.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [types[i],types[j]] = [types[j],types[i]];
    }
    return types;
  }

  function ghostY(board, piece){
    let y = piece.y;
    while(!collides(board, piece, piece.x, y+1, piece.rot)) y++;
    return y;
  }

  // === Game State ===
  let board = emptyBoard();
  let queue = bag7();
  let nextPiece = () => ({type: queue.length? queue.shift() : (queue = bag7(), queue.shift()), x:3, y:-2, rot:0, held:false});
  let current = nextPiece();
  let hold = null, holdUsed = false;
  let score = 0, lines = 0, level = 1;
  let dropInterval = DROP_START, lastTime = 0, acc = 0, paused = false, over = false;

  function levelSpeed(){
    const idx = Math.min(level-1, SPEED_TABLE.length-1);
    dropInterval = SPEED_TABLE[idx];
    elSpeed.textContent = `${(900/dropInterval).toFixed(1)}x`;
  }

  function spawn(){
    current = nextPiece();
    current.x = 3; current.y = -2; current.rot = 0; holdUsed = false;
    if(collides(board,current,current.x,current.y,current.rot)){
      over = true; showToast('Game Over');
    }
    drawSide();
  }

  function rotate(dir){
    const prev = current.rot;
    let rot = (current.rot + dir + 4) % 4;
    // simple wall kicks
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      if(!collides(board,current,current.x+k,current.y,rot)){ current.rot = rot; current.x += k; return; }
    }
    current.rot = prev;
  }

  function hardDrop(){
    if(over||paused) return;
    let dist = 0;
    while(!collides(board,current,current.x,current.y+1,current.rot)){ current.y++; dist++; }
    score += dist*2; // hard drop points
    lockPiece();
  }

  function softDrop(){
    if(over||paused) return;
    if(!collides(board,current,current.x,current.y+1,current.rot)){ current.y++; score += 1; }
    else lockPiece();
  }

  function move(dx){
    if(over||paused) return;
    if(!collides(board,current,current.x+dx,current.y,current.rot)) current.x += dx;
  }

  function holdSwap(){
    if(over||paused||holdUsed) return;
    if(!hold){ hold = {type: current.type}; spawn(); }
    else { const t = hold.type; hold.type = current.type; current = {type:t,x:3,y:-2,rot:0}; }
    holdUsed = true; drawSide();
  }

  function lockPiece(){
    merge(board,current);
    const cleared = clearLines(board);
    if(cleared){
      score += SCORES[cleared] || 0;
      lines += cleared;
      const newLevel = 1 + Math.floor(lines / 10);
      if(newLevel !== level){ level = newLevel; levelSpeed(); showToast(`Level ${level}`); }
    }
    spawn();
    updateUI();
  }

  function updateUI(){
    elScore.textContent = score; elLevel.textContent = level; elLines.textContent = lines;
  }

  function drawBoard(){
    bctx.clearRect(0,0,boardCanvas.width, boardCanvas.height);
    // settled blocks
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const t = board[y][x]; if(t) drawBlock(bctx,x,y,COLORS[t]);
      }
    }
    // ghost
    const gy = ghostY(board,current);
    const ghostShape = SHAPES[current.type][current.rot];
    for(const [dx,dy] of ghostShape){
      const gx = current.x + dx, gyy = gy + dy; if(gyy>=0) drawBlock(bctx,gx,gyy,COLORS.GHOST);
    }
    // current piece
    const shape = SHAPES[current.type][current.rot];
    for(const [dx,dy] of shape){
      const x = current.x + dx, y = current.y + dy; if(y>=0) drawBlock(bctx,x,y,COLORS[current.type]);
    }
  }

  function drawMini(ctx, type){
    ctx.clearRect(0,0,120,120);
    if(!type) return;
    const shape = SHAPES[type][0];
    // center
    const xs = shape.map(([x])=>x), ys = shape.map(([,y])=>y);
    const minx = Math.min(...xs), maxx = Math.max(...xs), miny = Math.min(...ys), maxy = Math.max(...ys);
    const offx = Math.floor((4 - (maxx-minx+1))/2) - minx;
    const offy = Math.floor((4 - (maxy-miny+1))/2) - miny;
    for(const [dx,dy] of shape){ drawCell(ctx, dx+offx, dy+offy, COLORS[type]); }
  }

  function drawSide(){
    drawMini(nctx, queue[0]);
    drawMini(hctx, hold && hold.type);
  }

  function reset(){
    board = emptyBoard(); queue = bag7(); current = nextPiece(); hold = null; holdUsed=false;
    score=0; lines=0; level=1; levelSpeed(); over=false; paused=false; acc=0; lastTime=0; updateUI(); drawSide(); showToast('Good luck!');
  }

  // === Game Loop ===
  function loop(ts){
    if(!paused && !over){
      if(lastTime===0) lastTime = ts;
      const dt = ts - lastTime; lastTime = ts; acc += dt;
      if(acc >= dropInterval){ acc = 0; softDrop(); }
      drawBoard();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // === Events ===
  window.addEventListener('keydown', (e)=>{
    switch(e.key){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowDown': softDrop(); break;
      case 'ArrowUp': rotate(1); break;
      case 'x': case 'X': rotate(1); break;
      case 'z': case 'Z': rotate(-1); break;
      case ' ': e.preventDefault(); hardDrop(); break;
      case 'Shift': holdSwap(); break;
      case 'p': case 'P': paused = !paused; showToast(paused? 'Paused' : 'Resumed'); break;
      case 'r': case 'R': reset(); break;
    }
  });

  document.getElementById('btn-restart').onclick = reset;
  document.getElementById('btn-pause').onclick = () => { paused=!paused; showToast(paused? 'Paused' : 'Resumed'); };

  // init
  levelSpeed(); updateUI(); drawSide();
})();
</script>
</body>
</html>
